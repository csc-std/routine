
module rust::core ;

import module cxx ;

using BOOL = cxx::bool ;

static constant TRUE = BOOL (cxx::true) ;
static constant FALSE = BOOL (cxx::false) ;

using VAR32 = cxx::int32 ;
using VAR64 = cxx::int64 ;

static constant VAR32_MAX =  VAR32 (+2147483647) ;
static constant VAR32_MIN =  VAR32 (-2147483648) ;
static constant VAR64_MAX =  VAR32 (+9223372036854775807) ;
static constant VAR64_MIN =  VAR32 (-9223372036854775808) ;

private trait VAR_HELP {
	require (macro ("config_int32")) ;

	using VAR = VAR32 ;

	static constant VAR_MAX = VAR32_MAX ;
	static constant VAR_MIN = VAR32_MIN ;
} ;

private trait VAR_HELP {
	require (macro ("config_int64")) ;

	using VAR = VAR64 ;

	static constant VAR_MAX = VAR64_MAX ;
	static constant VAR_MIN = VAR64_MIN ;
} ;

using VAR = VAR_HELP::VAR ;

static constant VAR_MAX = VAR_HELP::VAR64_MAX ;
static constant VAR_MIN = VAR_HELP::VAR64_MIN ;

static constant USED = VAR (-2) ;
static constant NONE = VAR (-1) ;
static constant ZERO = VAR (+0) ;
static constant IDEN = VAR (+1) ;

using INDEX = VAR ;
using LENGTH = VAR ;
using FLAG = VAR ;

using FLOAT32 = cxx::float32 ;
using FLOAT64 = cxx::float64 ;

static constant FLOAT32_MAX = FLOAT32 (3.402823466E+38) ;
static constant FLOAT32_MIN = FLOAT32 (1.175494351E-38) ;
static constant FLOAT32_EPS = FLOAT32 (1.192092896E-07) ;
static constant FLOAT32_INF = FLOAT32 (cxx::infinity) ;
static constant FLOAT64_MAX = FLOAT64 (1.7976931348623158E+308) ;
static constant FLOAT64_MIN = FLOAT64 (2.2250738585072014E-308) ;
static constant FLOAT64_EPS = FLOAT64 (2.2204460492503131E-016) ;
static constant FLOAT64_INF = FLOAT64 (cxx::infinity) ;

using BYTE = cxx::byte ;
using WORD = cxx::word ;
using CHAR = cxx::char ;
using FEAT = cxx::feat ;

using STRA = cxx::stra ;
using STRU8 = cxx::stru8 ;
using STRU16 = cxx::stru16 ;
using STRU32 = cxx::stru32 ;

private trait STR_HELP {
	require (macro ("config_stra")) ;

	using STR = STRA ;
} ;

private trait STR_HELP {
	require (macro ("config_stru8")) ;

	using STR = STRU8 ;
} ;

private trait STR_HELP {
	require (macro ("config_stru16")) ;

	using STR = STRU16 ;
} ;

private trait STR_HELP {
	require (macro ("config_stru32")) ;

	using STR = STRU32 ;
} ;

using STR = STR_HELP::STR ;

static constant NULL = cxx::null ;

define ENUM enum

define TYPE type

using ENUM_USED = ENUM (-2) ;
using ENUM_NONE = ENUM (-1) ;
using ENUM_ZERO = ENUM (+0) ;
using ENUM_IDEN = ENUM (+1) ;

using ALIGNOF<UNIT> = ENUM (cxx::alignof (UNIT)) ;
using SIZEOF<UNIT> = ENUM (cxx::sizeof (UNIT)) ;
using COUNTOF<UNIT> = ENUM (cxx::countof (UNIT)) ;

using ENUM_CHECK<EXPR> = ENUM_CHECK_HELP<EXPR>::RET ;
using ENUM_AND<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value & ENUM_CHECK<EXPR2>::value) ;
using ENUM_OR<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value | ENUM_CHECK<EXPR2>::value) ;
using ENUM_ALL<...> = ENUM_ALL_HELP<type<...>>::RET ;
using ENUM_ANY<...> = ENUM_ANY_HELP<type<...>>::RET ;
using ENUM_NOT<EXPR> = ENUM (!ENUM_CHECK<EXPR>::value) ;
using ENUM_EQ<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value == ENUM_CHECK<EXPR2>::value) ;
using ENUM_NOT_EQ<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value != ENUM_CHECK<EXPR2>::value) ;
using ENUM_COMPR<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value <=> ENUM_CHECK<EXPR2>::value) ;
using ENUM_LT<EXPR1 ,EXPR2> = ENUM (ENUM_COMPR<EXPR1 ,EXPR2>::value < ENUM_ZERO::value) ;
using ENUM_GT<EXPR1 ,EXPR2> = ENUM (ENUM_COMPR<EXPR1 ,EXPR2>::value > ENUM_ZERO::value) ;
using ENUM_LT_EQ<EXPR1 ,EXPR2> = ENUM (ENUM_COMPR<EXPR1 ,EXPR2>::value <= ENUM_ZERO::value) ;
using ENUM_GT_EQ<EXPR1 ,EXPR2> = ENUM (ENUM_COMPR<EXPR1 ,EXPR2>::value >= ENUM_ZERO::value) ;
using ENUM_IN<EXPR ,BEGIN ,END> = ENUM_AND<ENUM_GT_EQ<EXPR ,BEGIN> ,ENUM_LT<EXPR ,END>> ;
using ENUM_NOT_IN<EXPR ,BEGIN ,END> = ENUM_NOT<ENUM_IN<EXPR ,BEGIN ,END>> ;
using ENUM_ADD<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value + ENUM_CHECK<EXPR2>::value) ;
using ENUM_SUB<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value - ENUM_CHECK<EXPR2>::value) ;
using ENUM_MUL<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value * ENUM_CHECK<EXPR2>::value) ;
using ENUM_DIV<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value / ENUM_CHECK<EXPR2>::value) ;
using ENUM_MOD<EXPR1 ,EXPR2> = ENUM (ENUM_CHECK<EXPR1>::value % ENUM_CHECK<EXPR2>::value) ;
using ENUM_MAX<EXPR1 ,EXPR2> = CONDITIONAL<ENUM_GT_EQ<EXPR1 ,EXPR2> ,EXPR1 ,EXPR2> ;
using ENUM_MIN<EXPR1 ,EXPR2> = CONDITIONAL<ENUM_LT_EQ<EXPR1 ,EXPR2> ,EXPR1 ,EXPR2> ;

using DEF<UNIT> = UNIT ;

using PTR<UNIT> = () :UNIT ;

private trait PLACEHOLDER_HELP<ARG1> {
	require (ENUM_EQ<ARG1 ,ENUM_ZERO>) ;

	class PLACEHOLDER {} ;
} ;

private trait PLACEHOLDER_HELP<ARG1> {
	require (ENUM_GT<ARG1 ,ENUM_ZERO>) ;

	using R1X = PLACEHOLDER_HELP<ENUM_DECREASE<ARG1>>::PLACEHOLDER ;

	class PLACEHOLDER {
		public extend :R1X ;
	} ;
} ;

using PLACEHOLDER<RANK> = PLACEHOLDER_HELP<RANK>::PLACEHOLDER ;

static constant P0 = PLACEHOLDER<ENUM (0)> () ;
static constant P1 = PLACEHOLDER<ENUM (1)> () ;
static constant P2 = PLACEHOLDER<ENUM (2)> () ;
static constant P3 = PLACEHOLDER<ENUM (3)> () ;
static constant P4 = PLACEHOLDER<ENUM (4)> () ;
static constant P5 = PLACEHOLDER<ENUM (5)> () ;
static constant P6 = PLACEHOLDER<ENUM (6)> () ;
static constant P7 = PLACEHOLDER<ENUM (7)> () ;
static constant P8 = PLACEHOLDER<ENUM (8)> () ;
static constant P9 = PLACEHOLDER<ENUM (9)> () ;
static constant PX = PLACEHOLDER<ENUM (10)> () ;

using CONDITIONAL<COND ,YES ,NO> = CONDITIONAL_HELP<COND ,YES ,NO>::RET ;

using IS_SAME<UNIT1 ,UNIT2> = IS_SAME_HELP<UNIT1 ,UNIT2>::RET ;
using IS_ALL_SAME<...> = IS_ALL_SAME_HELP<type<...>>::RET ;
using IS_ANY_SAME<...> = IS_ANY_SAME_HELP<type<...>>::RET ;

using IS_BOOL<UNIT> = IS_SAME<UNIT ,BOOL> ;
using IS_VAR<UNIT> = ENUM_ALL<IS_SAME<UNIT ,VAR32> ,IS_SAME<UNIT ,VAR64>> ;
using IS_FLOAT<UNIT> = ENUM_ALL<IS_SAME<UNIT ,FLOAT32> ,IS_SAME<UNIT ,FLOAT64>> ;
using IS_BYTE<UNIT> = ENUM_ALL<IS_SAME<UNIT ,BYTE> ,IS_SAME<UNIT ,WORD> ,IS_SAME<UNIT ,CHAR> ,IS_SAME<UNIT ,FEAT>> ;
using IS_STR<UNIT> = ENUM_ALL<IS_SAME<UNIT ,STRA> ,IS_SAME<UNIT ,STRU8> ,IS_SAME<UNIT ,STRU16> ,IS_SAME<UNIT ,STRU32>> ;
using IS_BASIC<UNIT> = ENUM_ALL<IS_BOOL<UNIT> ,IS_VAR<UNIT> ,IS_FLOAT<UNIT> ,IS_BYTE<UNIT> ,IS_STR<UNIT>> ;

using IS_ENUM<UNIT> = IS_ENUM_HELP<UNIT>::RET ;

using IS_TYPE<UNIT> = IS_TYPE_HELP<UNIT>::RET ;

using IS_PLACEHOLDER<UNIT> = IS_PLACEHOLDER_HELP<UNIT>::RET ;

using IS_TEMP<UNIT> = IS_TEMP_HELP<UNIT>::RET ;
using REMOVE_TEMP<UNIT> = REMOVE_TEMP_HELP<UNIT>::RET ;

using TYPE_FIRST<ALL> = TYPE_FIRST_HELP<ALL>::RET ;
using TYPE_SECOND<ALL> = TYPE_SECOND_HELP<ALL>::RET ;
using TYPE_FIRST_REST<ALL> = TYPE_FIRST_REST_HELP<ALL>::RET ;
using TYPE_SECOND_REST<ALL> = TYPE_SECOND_REST_HELP<ALL>::RET ;
using TYPE_CAT<UNIT1 ,UNIT2> = type<UNIT1... ,UNIT2...> ;
using TYPE_GET<ALL ,POS> = TYPE_GET_HELP<ALL ,POS> ;
using TYPE_FIND<ALL ,KEY> = TYPE_FIND_HELP<ALL ,KEY> ;
using TYPE_REPEAT<UNIT ,SIZE> = TYPE_REPEAT_HELP<UNIT ,SIZE> ;

using IS_STRUCT<UNIT> = IS_STRUCT_HELP<UNIT>::RET ;
using REFLECT_STRUCT<UNIT> = REFLECT_STRUCT_HELP<UNIT>::RET ;
using STRUCT_BIND<PARAMS> = [...:PARAMS] ;

using IS_FUNCTION<UNIT> = IS_FUNCTION_HELP<UNIT>::RET ;
using REMOVE_FUNCTION<UNIT> = REMOVE_FUNCTION_HELP<UNIT>::RET ;
using REFLECT_FUNCTION<UNIT> = REFLECT_FUNCTION_HELP<UNIT>::RET ;
using FUNCTION_BIND<RETURN ,PARAMS> = (...:PARAMS) :RETURN ;

using IS_TRIVIAL<UNIT> = IS_TRIVIAL_HELP<UNIT>::RET ;
using IS_INTERFACE<UNIT> = IS_INTERFACE_HELP<UNIT>::RET ;

using IS_CLASS<UNIT> = IS_CLASS_HELP<UNIT>::RET ;
using IS_CLASS_CLONEABLE<UNIT> = concept (UNIT::clone) ;
using IS_CLASS_SHAREABLE<UNIT> = concept (UNIT::share) ;
using IS_CONSTRUCTIBLE<UNIT ,ALL> = IS_CONSTRUCTIBLE_HELP<UNIT ,ALL>::RET ;
using IS_CONVERTIBLE<FROM ,TO> = IS_CONVERTIBLE_HELP<FROM ,TO>::RET ;
using IS_EXTEND<BASE ,DERIVE> = IS_EXTEND_HELP<BASE ,DERIVE>::RET ;

using BYTE_TRAIT<UNIT> = BYTE_TRAIT_HELP<UNIT>::RET ;

define ASSERT assert

function noop = () => {
	ASSERT (TRUE) ;
} ;

function unimplemented = () => {
	ASSERT (FALSE) ;
} ;

function address = (obj) => {
	return cxx::address (obj) ;
} ;

function alignas = (base :LENGTH ,align :LENGTH) => {
	return base + (align - base % align) % align ;
} ;

function load = (arg1 ,owner ,addr :LENGTH) => {
	using R1X = TYPE (arg1) ;
	using R2X = TYPE (owner) ;
	require (IS_FUNCTION<R2X>) ;
	return cxx::load (arg1 ,owner ,addr) ;
} ;

function cast = (arg1 ,obj) => {
	using R1X = TYPE (arg1) ;
	using R2X = TYPE (obj) ;
	require (IS_FUNCTION<R2X>) ;
	using R3X = REMOVE_FUNCTION<R2X> ;
	require (ENUM_EQ<ALIGNOF<R1X> ,ALIGNOF<R3X>>) ;
	require (ENUM_EQ<SIZEOF<R1X> ,SIZEOF<R3X>>) ;
	constant r1x = address (obj) ;
	return load (arg1 ,obj ,r1x) ;
} ;

private trait COPY_HELP<ARG1> {
	require (IS_CLASS_SHAREABLE<ARG1>) ;

	function copy = (obj :ARG1) => obj.share () ;
} ;

private trait COPY_HELP<ARG1> {
	require (IS_CLASS_CLONEABLE<ARG1>) ;
	require (ENUM_NOT<IS_CLASS_SHAREABLE<ARG1>>) ;

	function copy = (obj :ARG1) => obj.clone () ;
} ;

private trait COPY_HELP<ARG1> {
	require (ENUM_NOT<IS_CLASS_CLONEABLE<ARG1>>) ;
	require (ENUM_NOT<IS_CLASS_SHAREABLE<ARG1>>) ;

	function copy = (obj :ARG1) => obj ;
} ;

function copy = (obj) => COPY_HELP<TYPE (obj)>::copy (obj) ;

function swap = (obj1 ,obj2) => {
	using R1X = TYPE (obj1) ;
	using R2X = TYPE (obj2) ;
	require (IS_SAME<R1X ,R2X>) ;
	##???##
} ;

using UNION<ALIGN ,SIZE> = UNION_HELP<ALIGN ,SIZE>::UNION ;

class Proxy {} ;

implement Proxy {
	function clone = () => delete ;
	function share = () => delete ;
} ;

interface Nullable {
	function is_null = () :BOOL => virtual ;
} ;

class TEMP<UNIT> {
	public variant mStorage :UNION<ALIGNOF<UNIT> ,SIZEOF<UNIT>> ;
} ;

implement TEMP<UNIT> {
	function zeroize = () => {
		using R1X = UNION<ALIGNOF<UNIT> ,SIZEOF<UNIT>> ;
		mStorage = R1X => {0} ;
	} ;
} ;

class Slice<REAL> {
	interface Holder ;
	class ImplHolder<WRAP> ;

	constant mPointer :PTR<Holder> ;
} ;

interface Slice<REAL>::Holder {
	function size = () :LENGTH => virtual ;
	function get = (index :INDEX) :REAL => virtual ;
} ;

class Slice<REAL>::ImpleHolder<WRAP> {
	constant mTuple :PTR<WRAP> ;
	constant mSize :LENGTH ;
} ;

implement Slice<REAL>::ImpleHolder<WRAP> {
	function new = () => delete ;

	function new = (that :PTR<WRAP>) => {
		mTuple = that ;
		mSize = mTuple->capaticy () ;
	} ;
} ;

implement Slice<REAL>::ImpleHolder<WRAP> :Holder {
	function size = () => mSize ;

	function get = (index :INDEX) :REAL => {
		return mTuple->[index] ;
	} ;
} ;

implement Slice<REAL> {
	function new = () => {
		mPointer = NULL ;
	} ;
	
	function new = (that) => {
		using R1X = TYPE (that) ;
		using R2X = REMOVE_FUNCTION<R1X> ;
		static constant M_HOLDER = ImplHolder<R2X> (PTR<R2X> => that) ;
		mPointer = PTR<Holder> => M_HOLDER ;
	} ;

	function size = () :LENGTH => {
		if (mPointer == NULL)
			return 0 ;
		return mPointer->size () ;
	} ;

	function get = (index :INDEX) :REAL => {
		ASSERT (index >= 0 && index < size ()) ;
		return mPointer->get (index) ;
	} ;

	function equal = (that :Slice) => {
		if (size () != that.size ())
			return FALSE ;
		for i in range (0 ,size ()) => {
			if (get (i) != that.get (i))
				return FALSE ;
		} ;
		return TRUE ;
	} ;

	function compr = (that :Slice) => {
		constant r1x = min (size () ,that.size ()) ;
		for i in range (0 ,r1x) => {
			constant r4x = get (i) <=> that.get (i) ;
			if (r4x != 0)
				return r4x ;
		} ;
		constant r3x = size () <=> that.size () ;
		if (r3x != 0)
			return r3x ;
		return TRUE ;
	} ;
} ;

class Class {
	interface Holder ;
	class Reflection ;
	class ImplHolder<WRAP> ;

	constant mPointer :PTR<Holder> ;
} ;

interface Class::Holder {
	function type_hash = () :FLAG => virtual ;
	function type_align = () :LENGTH => virtual ;
	function type_size = () :LENGTH => virtual ;
	function type_name = () :Slice<STR> => virtual ;
	function reflect = () :PTR<Reflection> => virtual ;
} ;

class Class::Reflection {
	public constant mType :Class ;
	public constant mOffset :LENGTH ;
	public constant mMember :Slice<STR> ;
	public constant mPrev :PTR<Reflection> ;
	public constant mNext :PTR<Reflection> ;
} ;

class Class::ImplHolder<WRAP> {} ;

implement Class::ImplHolder<WRAP> :Holder {
	function type_hash = () :FLAG => address (this) ;

	function type_align = () :LENGTH => ALIGNOF<WRAP>::value ;

	function type_size = () :LENGTH => SIZEOF<WRAP>::value ;

	function type_name = () :Slice<STR> => {
		return cxx::type_name (type<WRAP>::id) ;
	} ;

	function reflect = () :PTR<Reflection> => {
		return cxx::reflect (type<WRAP>::id) ;
	} ;
} ;

implement Class {
	function new = () => delete ;

	function new = (arg1) => {
		using R1X = TYPE (arg1) ;
		static constant M_HOLDER = ImplHolder<R1X> () ;
		mPointer = PTR<Holder> => M_HOLDER ;
	} ;
	
	function type_hash = () :FLAG => mPointer->type_hash () ;

	function type_align = () :LENGTH => mPointer->type_align () ;

	function type_size = () :LENGTH => mPointer->type_size () ;

	function type_name = () :Slice<STR> => mPointer->type_name () ;

	function equal = (that :Class) => {
		if (type_hash () != that.type_hash ())
			return FALSE ;
		if (type_name () != that.type_name ())
			return FALSE ;
		return TRUE ;
	} ;

	function compr = (that :Class) => {
		constant r1x = type_hash () <=> that.type_hash () ;
		if (r1x != 0)
			return r1x ;
		constant r2x = type_name () <=> that.type_name () ;
		if (r2x != 0)
			return r2x ;
		return FLAG (0) ;
	} ;
} ;

class Exception {
	constant mWhat :Slice<STR> ;
} ;

implement Exception {
	function new = () => default ;

	function new = (that :Slice<STR>) {
		mWhat = that ;
	} ;

	function what = () :Slice<STR> => mWhat ;

	function raise = () => {
		cxx::raise (this) ;
	} ;
} ;

class Iterator<WRAP> {
	constant mArray :PTR<WRAP> ;
	constant mBad :INDEX ;
	variant mIndex :INDEX ;
} ;

implement Iterator<WRAP> {
	function new = () => delete ;

	function new = (array :PTR<WRAP>) => {
		mArray = array ;
		mIndex = mArray->ibegin () ;
		mBad = mArray->iend () ;
	} ;

	function next = () => {
		mIndex = mArray->inext (mIndex) ;
	} ;

	function good = () :BOOL => mIndex != mBad ;

	function get = () :INDEX => mIndex ;
} ;

class Syntex {} ;

class Reference {} ;

class SafeReference<UNIT> {
	public extend :Reference ;
	constant mPointer :PTR<UNIT> ;
} ;

implement Reference :Nullable {
	function is_null = () :BOOL => mPointer == NULL ;
} ;

implement SafeReference<UNIT> {
	function new = () => delete ;

	private trait NEW_HELP<ARG1> {
		require (IS_SAME<ARG1 ,PTR<UNIT>>) ;
		
		function new = (that :PTR<UNIT>) => {
			mPointer = that ;
		} ;
	} ;

	private trait NEW_HELP<ARG1> {
		require (IS_SAME<ARG1 ,Reference>) ;

		function new = (that :Reference) => {
			ASSERT (that != NULL) ;
			##???##
			mPointer = that.mPointer ;
		} ;
	} ;

	function new = (that) => NEW_HELP<TYPE (that)>::new (that) ;

	function to = () :PTR<UNIT> => mPointer ;
} ;

implement SafeReference<UNIT> :Nullable {
	function is_null = () :BOOL => mPointer == NULL ;
} ;