module rust::basic

import module rust::core ;

private trait ENUM_MAX_ALIGN_HELP<UNITS> {
	using R1X = ENUM_MAX_ALIGN<TYPE_FIRST_REST<UNITS>> ;
	using RET = ENUM_MAX<ALIGNOF<TYPE_FIRST<UNITS>> ,R1X> ;
} ;

private trait ENUM_MAX_SIZE_HELP<UNITS> {
	using R1X = ENUM_MAX_SIZE_HELP<TYPE_FIRST_REST<UNITS>> ;
	using RET = ENUM_MAX<SIZEOF<TYPE_FIRST<UNITS>> ,R1X> ;
} ;

class Variant<UNITS> {
	interface Holder ;
	class ImplHolder<WRAP> ;
	using VARIANT = UNION<ENUM_MAX_ALIGN_HELP<UNITS>::RET ,ENUM_MAX_SIZE_HELP<UNITS>::RET> ;

	variant mVariant :TEMP<VARIANT> ;
	variant mIndex :INDEX ;
} ;

interface Variant<UNITS>::Holder {
	function deref = () :PTR<void> => virtual ;

	function friend_clone = (that :PTR<TEMP<VARIANT>>) => virtual ;
} ;

class Variant<UNITS>::ImplHolder<WRAP> {
	variant mValue :WRAP ;
} ;

implement Variant<UNITS>::ImplHolder<WRAP> {
	function new = () => default ;

	function new = (that :WRAP) => {
		mValue = that ;
	} ;
} ;

implement Variant<UNITS>::ImplHolder<WRAP> :Holder {
	function deref = () :PTR<void> => {
		return () => mValue ;
	} ;

	function friend_clone = (that :PTR<TEMP<VARIANT>>) => {
		constant r1x = cast (type<TEMP<ImplHolder>>::id ,that) ;
		cxx::create (r1x ,mValue) ;
	} ;
} ;

implement Variant<UNITS> {
	function new = () => default ;

	function new = (that) => {
		using R1X = TYPE (that) ;
		require (ENUM_NOT_EQ<TYPE_FIND<UNITS ,R1X> ,ENUM_NONE>) ;
		mIndex = 0 ;
	} ;

	function delete = () => {
		if (mIndex == ZERO)
			return ;
		constant r1x = fake () ;
		cxx::destroy (r1x) ;
		mIndex = ZERO ;
	} ;

	function clone = () => {
		variant ret = Variant () ;
		switch {
			if (mIndex == ZERO)
				discard ;
			constant r1x = fake () ;
			constant r2x = () => ret.mVariant ;
			r1x->friend_clone (r2x) ;
			ret.mIndex = mIndex ;
		}
		return ret ;
	} ;

	private function fake = () :PTR<Holder> => {
		

	} ;
} ;

using Optional<UNIT> = Variant<type<UNIT>> ;