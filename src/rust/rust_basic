module rust::basic

import module rust::core ;

private trait ENUM_MAX_ALIGN_HELP<ARGS> {
	using R1X = ENUM_MAX_ALIGN_HELP<TYPE_FIRST_REST<ARGS>> ;
	using RET = ENUM_MAX<ALIGNOF<TYPE_FIRST<ARGS>> ,R1X> ;
} ;

private trait ENUM_MAX_SIZE_HELP<ARGS> {
	using R1X = ENUM_MAX_SIZE_HELP<TYPE_FIRST_REST<ARGS>> ;
	using RET = ENUM_MAX<SIZEOF<TYPE_FIRST<ARGS>> ,R1X> ;
} ;

class Variant<UNITS> {
	require (ENUM_NOT<IS_ANY_SAME<UNITS>...>) ;

	interface Holder ;
	class ImplHolder<WRAP> ;
	using VARIANT = UNION<ENUM_MAX_ALIGN_HELP<UNITS>::RET ,ENUM_MAX_SIZE_HELP<UNITS>::RET> ;

	variant mVariant :TEMP<VARIANT> ;
	constant mIndex :INDEX ;
} ;

interface Variant<UNITS>::Holder {
	function deref = () :Reference => virtual ;

	function friend_clone = (that :SafeReference<TEMP<VARIANT>>) :INDEX => virtual ;
} ;

class Variant<UNITS>::ImplHolder<WRAP> {
	variant mValue :WRAP ;
} ;

implement Variant<UNITS>::ImplHolder<WRAP> {
	function new = () => default ;

	function new = (that :WRAP) => {
		mValue = that ;
	} ;
} ;

implement Variant<UNITS>::ImplHolder<WRAP> :Holder {
	function deref = () => {
		return PTR<Reference> => SafeReference<WRAP> (mValue) ;
	} ;

	function friend_clone = (variant_ :SafeReference<TEMP<VARIANT>>) => {
		constant r1x = load (type<ImplHolder>::id ,variant_ ,address (variant_)) ;
		r1x->new (mValue) ;
		return TYPE_FIND<UNITS ,WRAP>::value ;
	} ;
} ;

implement Variant<UNITS> {
	function new = () => {
		mVariant.swap () ;
		mIndex = NONE ;
	} ;

	function new = (that) => {
		using R1X = type (that) ;
		require (ENUM_NOT_EQ<TYPE_FIND<UNITS ,R1X> ,ENUM_NONE>) ;
		this.new () ;
		constant r1x = () => ImplHolder<R1X> (that) ;
		variant rax = SafeReference<TEMP<VARIANT>> (mVariant) ;
		mIndex = r1x->friend_clone (rax) ;
	} ;

	function delete = () => {
		if (mIndex == NONE)
			return ;
		constant r1x = fake () ;
		r1x->delete () ;
		mIndex = NONE ;
	} ;

	function clone = () => {
		if (mIndex == VAR_NONE)
			return Variant () ;
		constant r1x = fake () ;
		constant r2x = SafeReference<TYPE_FIRST<UNITS>> (r1x->deref ()) ;
		return Variant (r2x) ;
	} ;

	function share = () => delete ;

	private function fake = () => {
		if (mIndex == NONE)
			return PTR<Holder> (NULL) ;
		return FAKE_HELP<ENUM_ZERO>::fake (mIndex) ;
	} ;

	private trait FAKE_HELP<ARG1> {
		require (ENUM_BETWEEN<ARG1 ,ENUM_ZERO ,COUNTOF<UNITS>>) ;

		function fake = (index :INDEX) => {
			if (ENUM_CHECK<ARG1>::value == index)
				return load (type<ImplHolder<TYPE_GET<UNITS ,ARG1>>>::id ,mVariant ,address (mVariant)) ;
			return FAKE_HELP<ENUM_INCREASE<ARG1>>::fake (index) ;
		} ;
	} ;

	private trait FAKE_HELP<ARG1> {
		require (ENUM_NOT<ENUM_BETWEEN<ARG1 ,ENUM_ZERO ,COUNTOF<UNITS>>>) ;

		function fake = (index :INDEX) => PTR<Holder> (NULL) ;
	} ;

	function exist = () => mIndex != NONE ;

	function to = () => {
		require (ENUM_EQ<COUNTOF<UNITS> ,ENUM_IDEN>) ;
		constant r1x = fake () ;
		return PTR<TYPE_FIRST<UNITS>> => SafeReference<TYPE_FIRST<UNITS>> (r1x->deref ()) ;
	} ;

	function apply = (proc) => {
		using R1X = type (proc) ;
		require (IS_FUNCTION<R1X>) ;
		using R2X = REFLECT_FUNCTION<R1X>::SECOND ;
		require (ENUM_EQ<COUNTOF<R2X> ,ENUM_IDEN>) ;
		using R3X = R2X::FIRST ;
		if (TYPE_FIND<UNITS ,R3X>::value != mIndex)
			return ;
		constant r1x = fake () ;
		constant r2x = SafeReference<TYPE_FIRST<UNITS>> (r1x->deref ()) ;
		proc (r2x) ;
	} ;
} ;

using Optional<UNIT> = Variant<type<UNIT>> ;